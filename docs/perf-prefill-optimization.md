# 预填性能优化方案

面向“患者病案首页预填”链路的性能改进任务清单，可逐项执行与验收。文档语言：简体中文。

## 目标与范围
- 目标：将首屏预填完成时间从约 3s 降至可接受阈值（待确认），降低首屏阻塞请求数，减少重复调用。
- 范围：后端 `prefill` 服务链路（外部视图访问、缓存、日志）、前端 RecordForm 首屏加载（预填、字典、渲染）、监控与验收流程。

## 任务列表（含需确认项）

### 后端
1) 预填并行化与超时保护  
   - 将基础信息、费用、诊断查询改为并发；为单查询与整体请求增加超时和降级（诊断可弱依赖）。  
   - 需确认：外部数据源允许的并发度/超时阈值；诊断是否可懒加载或弱依赖。

2) 连接池与预热  
   - 配置 sqlserver/oracle 引擎的 pool_size/max_overflow/pool_timeout，启动或首访前预热连接。  
   - 需确认：外部库最大连接数限制；能否接受启动预热。

3) 短期缓存与重试策略  
   - 对同一 `patient_no` 短时间重复预填做短期缓存；对外部查询增加有限重试/回退。  
   - 需确认：缓存有效期；是否存在“必须实时”的场景。

4) 分段耗时日志与监控  
   - 在 `prefill` 路径打点：base/fee/diagnosis/总耗时、连接池等待、外部错误类型；接入 APM/日志。  
   - 需确认：日志级别与采样率；是否有既有监控规范。

5) 诊断查询懒加载（可选）  
   - 首屏仅取基础+费用，诊断进入诊断分区时再取，提供诊断独立接口。  
   - 需确认：业务是否允许首屏不带诊断；接口拆分可行性。

6) 数据源侧优化（DBA 配合）  
   - 检查 `V_EMR_*` 视图执行计划/索引，必要时加索引或物化/中间表。  
   - 需确认：DBA 可操作范围；视图是否只读不可调优。

### 前端
7) 避免开发模式双请求  
   - 在 `loadAll` 加“首轮已执行”保护，或在开发环境关闭 StrictMode 双调用。  
   - 需确认：是否保留 StrictMode 用于调试；生产是否已无双请求。

8) 字典请求延后与缓存  
   - 预填字段直接使用已有值，字典下拉改为聚焦/展开时再查；常用 set 做本地缓存。  
   - 需确认：是否接受首次点击才加载选项；后端是否能返回 label 供直接显示。

9) 字典请求并发控制  
   - 对首屏 5 个字典请求限速（如并发 1-2）+ 防抖 + 去重，避免堵塞关键链路。  
   - 需确认：可接受的并发阈值与用户体验取舍。

10) 预填加载与重试体验  
    - 显示“预填加载中/失败重试”，首个失败自动重试一次；失败时允许继续手填（可配置）。  
    - 需确认：重试次数与间隔；失败时的交互文案。

11) 诊断懒加载配合（若后端拆分）  
    - 进入诊断分区或点击“加载诊断”时再请求；无数据时提示可重试。  
    - 需确认：是否自动加载；文案与交互。

12) 资源加载优化（次优先级）  
    - 路由级代码分割，RecordForm 大组件使用 React.lazy；按需加载非首屏组件。  
    - 需确认：现有构建体积与拆分策略；对路由切换体验的要求。

13) 前端埋点与监控  
    - 埋点：`prefill start/end`、`dict ready`、`record ready`，上报耗时对比优化前后。  
    - 需确认：上报目标（日志/监控平台）；是否已有埋点链路。

### 协同与验证
14) 性能指标对齐  
    - 确定首屏可接受时长（目标/警戒），约定测试路径与患者样本。  
    - 需确认：具体 SLA；测试/生产环境差异。

15) 验证方案  
    - 对照测试：同一 `patient_no`，记录 `/prefill` 耗时、字典请求耗时、首屏可交互时间；优化前后对比。  
    - 需确认：是否能在预生产复刻外部数据源；样本量与时间窗。

## 使用方式
- 依任务顺序或按阻塞程度优先执行，执行前先确认“需确认”项。
- 每项完成后记录实际耗时变化，更新本文件或追加验证结果。***
